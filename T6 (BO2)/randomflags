#include maps/mp/gametypes/_hud;
#include maps/mp/gametypes/_hud_util;
#include maps/mp/_utility;
#include common_scripts/utility;

init()
{
    level thread configureoutofmaps();
}

configureoutofmaps()
{
    mapname = getDvar("mapname");
    switch(mapname)
    {
        case "mp_nuketown_2020":
            level thread nuketown();
            break;

        default:
            break;
    }
}

nuketown()
{
    //create the flag     //enter coords                   //exit coords
    createFlagRandom((42.4017, -589.359, 66.8609), (-5361.66, -3148.39, 1108.04));
    createFlagRandom((-1932.45, 158.224, -61.875), (3528.68, 18574.4, 3084.05));
    createFlagRandom((-818.865, 736.385, -63.2463), (64.766, -5377.65, 705.398));
    createFlagRandom((591.332, 329.957, -56.875), (2349.25, 6263.29, 374.606));
    createFlagRandom((1190.94, 177.699, -62.875), (7808.17, -2700.29, 1601.03));
}

//random exit coord index
nuketownec(index)
{
    switch(index)
    {
        case 0: return (-5361.66, -3148.39, 1108.04);
        case 1: return (3528.68, 18574.4, 3084.05);
        case 2: return (64.766, -5377.65, 705.398);
        case 3: return (2349.25, 6263.29, 374.606);
        case 4: return (7808.17, -2700.29, 1601.03);
            default: return (0,0,0);
    }
}

flagThink(Flag1, Flag2)
{
    level endon("game_ended");
    for(;;)
    {
        foreach(player in level.players)
        {
            if(Distance(player.origin, Flag1.origin) < 25)
            {
                if(getDvar("mapname") == "mp_nuketown_2020") 
                {
                    randomIndex = randomInt(5);
                    exitCoord = nuketownec();
                }

                player setOrigin(exitCoord); //teleports you to one of the random exit coords
                self freezeControls(true);
                wait 0.05;
                self freezecontrols(false);
            }
        }
        wait 0.02;
    }
}

spawnEntity(entityClass, model, origin, angle, solid)
{
    entity = spawn(entityClass, origin);
    entity.angles = angle;
    entity setModel(model);
    level.entities[level.amountofentities] = entity;
    level.amountofentities++;
    if(isDefined(solid))
    {
        entity notsolid();
    }
    return entity;
}
